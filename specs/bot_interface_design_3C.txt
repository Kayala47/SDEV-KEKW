Component Design - Bot Interface Module

Team: Discord Dragons
    Members: Dana, Kevin, Max, Swamik
    Project: 3C: Component Design
    Primary Author: Swamik Lamichhane
    Slip Days: 0

PURPOSE: 

The purpose of this module is to handel the user inputs and to act as the user interface. As such, the purpose of 
most of the functions in this module will be getting the user input ready for calls to other modules, and how to 
handel invalid inputs. The functions described are public methods and the only way for users to interact with out bot. 

All of the functions below listen to user input using discord's built in methods. The primary listening mechanism 
will be the bot.on('message', ...). What this built in function does is listen to all of the messages written by all 
of the users in the text chanel. Then if the message starts with the chosen prefix, it will know that it is a command. Then 
depending on what the command is it will do a different functon. 

// Pseudocode 

// Global  
PREFIX_LIST = [!, $, -, ?, /]
PREFIX = one value in PREFIX_LIST

bot.on('message', function (user, userID, channelID, message, evt) {

    // this is how we tell if the user is asking the bot to do a command 
    if (message.substring(0,1) == 'PREFIX'){
        args = message.substring(1).split (' ') // splitting the message by a space 
        cmd = args [0] // cmd is the name of the command that the user wants to do 
        // since we split the initial message by ' ', the inputs for the commands are also in the args list 

        // Now we have the cmd so we will have different functions depending on the cmd  

    if cmd == help: 
            return a message to the text channel with basic information about how to use the bot funcitons 
    
    // normal roll 
    // inputs for roll should be in the format [number of dice]d[sides of dice] + [modifier] or just roll with nothing after it 
    if cmd == roll: 
            if args[1] == "": // they called roll with no inputs 
                result = call to the roll function in the rolling module 
                return result as message in the channel
            else: 
                roll = split args[1] by 'd'  // the format is [number of dice]d[sides of dice]) so we will get the numbers 
                num_dice = roll[0]
                dice_sides = roll [1]
                if args[2] == "+" // checking to see if the user inputted a modifier
                    modifier = args[3] // this would be the modifier
                else: 
                    modifier = 0
            if modifier AND num_dice AND dice_sides are ints: // make sure that user inputs are the correct type 
                return the result from the call the muoltiroll function from the roll module with the three inputs as an imbedded message

    // fudge roll 
    // inputs for roll should be in the format [number of dice]d[sides of dice] + [modifier] [predetermined dice result]
    if cmd == froll: 
        if args[1] == "":
            return // did not have the correct format of input so return nothing 
        else: 
            if args[3] is an int: // this is the roll that the user wants to show 
                return args[3] as imbedded message

    // manual roll 
    // the inputs should be in format [physical dice results] // the dice rolls seperated by commas 
    if cmd == mroll: 
        rolls = split args[1] by ',' // to get all of the rolls seperated from eachother 
        result = ""
        loop though the rolls list:    
            result = result + call the manual roll function from the roll module with inputs = the values inside roll  
        return result as imbedded message 

    // joining the initive tracker 
    // inputs should be [name] [initiative modifier]
    if cmd == init_joinR: 
        name = args [1]
        modifier = args [2]
        if name != "" AND modifier != null: // check to see that name and modifier are not null 
            call the inititve join function with the input of the user's name and the dice modifier
        else: 
            return a message telling the user how to use init_joinR

    // joining the initive tracker 
    // inputs should be [name] [initiative roll]
    if cmd == init_joinM: 
        name = args [1]
        roll = args [2]
        if name != "" AND roll != null: // check to see that name and modifier are not null 
            call the manual inititve join function with the input of the user's name and the roll result 
        else: 
            return a message telling the user how to use init_joinM

    // starting or ending the initive tracker 
    if cmd == init 
            if args[1] == begin: 
                return the result from a call to the init begin function from the initive module as imbedded message 
            else if args[1] == end: 
                return the result from a call to the init end function from the initive module as imbedded message 
            else: // users used a command not in our system 
                return a list of commands that users can do using init

        // we will also have an emoji reaction functinality: Users can give emoji reactions to the message returned by the bot and do an action
        message.awaitReact("EMOJI"): 
            call the logic for each specific emoji case from the inititve tracker module 

    // the search funciton 
    // inputs should be [spell/background/feat/class/race/monster/item] [keyword]
    if cmd == search: 
        searchWord1 = args[1]
        searchWord2 = args[2]
        result = call to the search module with searchWord1 and searchWord2 as inputs
        return the result as imbedded message in the chat channel
    }
})

