Testing Plan - Bot Interface Module

Team: Discord Dragons
    Members: Dana, Kevin, Max, Swamik
    Project: 3C: Component Design
    Primary Author: Swamik Lamichhane
    Slip Days: 0

Note: The primary funciton of this module is to ensure that the 
bot is understanding the commands of the user and then is outputting 
the correct value onto the chat. As this module has more to do with what 
the user inputs on the screen and what the user then sees on the screen 
many funciton in this cannot be fully automated as we need to see what messages 
the bot is sending to the channel. 

With that in mind, the automated tests that I could have is to check if the outputs 
of the calls made to the functions from the other modules and make sure that they 
are in the correct range/ domain. This, however, would be rudundent as the testing 
plans for those other modules will already test for those types of mistakes. As such, 
for this module, there needs to be more of a manual process for checking the funcinality 
than other modules. Also since we have a pretty small amount of user commands, we can make this 
process more manual than if there were a lot of user commands. Furthermore, much of our functions 
do not have one single "correct answer" so automated to check the correctness is also difficult. 

To do testing for this process, and to make it slightly more autonomous, a new section of code 
will either be added to the orginal DnD bot or a new seperate testing bot will be made so that we can 
send messages to the chat channel. The messages will be sent automated, but we need to manually 
check that the responses from the bot are being sent to the chat in the correct format. Meaning 
we need to ensure that the responses from the bot are showing up in chat how we want them to show up. 

The main criteria for correctness in this module is that we are getting responses from the bot to 
every command that we are coding for. We want to make sure that the bot is listening to the chat 
and then is approprietly calling the correct function. The code that actually generates the values 
that are supposed to be sent is done in other modules so we just want to make sure the bot is listening
and then calling the correct command. The testing process does not need any special set-up, we just need 
to have the bot in a chat and send messages to the bot. We expect the users to use all of the functions 
listed below at least once in their campain and is normal behavior. The bot is only sending messages to 
chat, so there is no special clean up that needs to be done after. 

The great part of the discord bot listening to user commands is that if the command is not in the correct 
format with what we had specified in the code, most of the code does not run. Essentially, when we run the function in 
the bot, the input is clean enough to not cause serious misbehavior. There are some functions that we need to add additional 
white box tests to check misbehavior but most functions listed below will not have that type of misbehavior. 

Index of functions to be tested: help, roll, froll, mroll, init begin, init_joinR, init_joinM, init end, search


# This testing bot will be listening to the messages sent in the chat, and when the correct messages
# is sent to start the testing process, it will start testing 

@client.event
async def on_message(message):
    # we do not want the bot to reply to itself
    if message.author == client.user:
        return

    # checkes to see if a messege starts with !testStart. this is the key word to 
    # start the testing process 
    if message.content.startswith('!testStart'):
        msg = 'Starting the testing process'.format(message)
        await message.channel.send(msg)

        # calling the help function, we will see if the format of the 
        # returned message is correct. No real way to have misbehavior
        await message.channel.send("!help")


        # there are 3 possible paths in the roll function, need to test all 3 

        # calling the roll function, we will see if the format of the 
        # returned message is correct 
        await message.channel.send("!roll")

        # calling the multiroll function, we will see if the format of the 
        # returned message is correct 
        # first case with no modifier 
        await message.channel.send("!roll 2d20")
        # second case with a modifier 
        await message.channel.send("!roll 2d20 + 5")

        # what if we do not give ints as inputs: the function should not return anything 
        await message.channel.send("!roll AdR + D")

        
        # checking the fudge roll. check to see that the message 
        # returned to the channel is what we set it to 
        await message.channel.send("!froll 2d20 + 5 10") # the message should send back a 10

        # if not in correct format, should return nothing 
        # A is not an int so returns nothing 
        await message.channel.send("!froll 2d20 + 5 A") 


        # calling the manual roll function, we will see if the format of the 
        # returned message is correct 
        await message.channel.send("!mroll [10,12,15]")

        # this is to check that the initive tracker is started. When it starts, an empty csv file should be made 
        await message.channel.send("!init begin")  

        # calling the automated init_joinR function, we will have to see if the bot sends the 
        # response to the chat. We will have to see both the csv file containing the initive tracker 
        # and what the bot sent to the chat and see if they match 
        await message.channel.send("!inti_joinR 5")

        # calling the manual init_joinM function, we will have to see if the bot sends the 
        # response to the chat with the people added in the correct order. The automated join above and 
        # this manual join, the people need to be in the correct order. We will have to see 
        # both the csv file containing the initive tracker and what the bot sent to the chat and see 
        # if they match 
        await message.channel.send("!init_joinM 10")

        # to end the initive tracker, the csv file should be deleated. 
        await message.channel.send("!init end")

        # checking the search: the checking of the API search with the information on the web will 
        # be done in the search module so here we just want to check if the messages are being sent 
        # in the correct format. 
        await message.channel.send("!search monk dragonborn")






